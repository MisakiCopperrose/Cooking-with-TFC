package com.dunk.tfc.WorldGen.GenLayers.Mountains;

import com.dunk.tfc.Core.TFC_Climate;
import com.dunk.tfc.Core.TFC_Core;
import com.dunk.tfc.WorldGen.TFCBiome;
import com.dunk.tfc.WorldGen.TFCProvider;
import com.dunk.tfc.WorldGen.TFCWorldChunkManager;
import com.dunk.tfc.WorldGen.GenLayers.GenLayerTFC;
import com.dunk.tfc.api.Constant.Global;

import net.minecraft.server.MinecraftServer;
import net.minecraft.world.World;
import net.minecraft.world.WorldProvider;
import net.minecraft.world.gen.layer.GenLayer;

public class GenLayerMountainRangeTFC extends GenLayerTFC
{
	public GenLayerMountainRangeTFC(long par1, GenLayer par3GenLayer)
	{
		super(par1);
		super.parent = (GenLayerTFC) par3GenLayer;
	}

	/**
	 * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
	 * amounts, or biomeList[] indices based on the particular GenLayer subclass.
	 */
	@Override
	public int[] getInts(int xCoord, int zCoord, int xSize, int zSize)
	{
		//float rainfall = this.
		World world = null;//MinecraftServer.getServer().getEntityWorld();
		//float rainfall = 0f;//TFC_Climate.getRainfall(world,xCoord<<2,Global.SEALEVEL,zCoord<<2);
		if(MinecraftServer.getServer() != null && MinecraftServer.getServer().worldServers.length > 0)
		{
			world = MinecraftServer.getServer().getEntityWorld();
		}
		/*rainfall += 800;*/
		int areaRadius = 14;
		int peakRadius = 2;
		int rangeRadius = 9;
		int parentXCoord = xCoord - areaRadius;
		int parentZCoord = zCoord - areaRadius;
		int parentXSize = xSize + (2*areaRadius);
		int parentZSize = zSize + (2*areaRadius);
		int[] parentCache = new int[parentXSize * parentZSize];//this.parent.getInts(parentXCoord, parentZCoord, parentXSize, parentZSize);
		int[] parentCache2 = this.parent.getInts(parentXCoord, parentZCoord, parentXSize, parentZSize);
		
		for (int z = 0; z < parentZSize + 0; ++z)
		{
			for (int x = 0; x < parentXSize + 0; ++x)
			{
				if(world != null)
				{
					parentCache[x + z * parentZSize] = TFC_Climate.getRegionLayer(world, (parentXCoord+x)<<2, Global.SEALEVEL, (parentZCoord+z)<<2);
				}
				else
				{
					parentCache[x + z * parentZSize] = 0;
				}
			}
		}
		
		
		int[] outCache = new int[(xSize+0) * (zSize+0)];
		
		
		for (int z = 0; z < zSize + 0; ++z)
		{
			for (int x = 0; x < xSize + 0; ++x)
			{
				int index = areaRadius + x + (z +areaRadius)* parentXSize;
				boolean canDoPeak = parentCache2[index]==3;
				boolean canDoEdge = parentCache2[index] >=2;
				boolean canDoFoothills = parentCache2[index] >=1;
				index = x + z * xSize;
				/*
				int xMinus = this.calcWidth(parentCache[x + 0 + (z + (1*areaRadius)) * parentXSize]);
				int xPlus = this.calcWidth(parentCache[x + (2*areaRadius) + (z + (1*areaRadius)) * parentXSize]);
				int zMinus = this.calcWidth(parentCache[x + (1*areaRadius) + (z + 0) * parentXSize]);
				int zPlus = this.calcWidth(parentCache[x + (1*areaRadius) + (z + (2*areaRadius)) * parentXSize]);
				int c = this.calcWidth(parentCache[x + (1*areaRadius) + (z + (1*areaRadius)) * parentXSize]);*/
				//int[][]areas = new int[(areaRadius*2)+1][(areaRadius*2)+1];
				boolean same = canDoFoothills;
				boolean same2 = canDoPeak;
				boolean same3 = canDoEdge;
				boolean initialVal = false;
				int initialValue = -1;
				boolean initialVal2 = false;
				int initialValue2 = -1;
				boolean initialVal3 = false;
				int initialValue3 = -1;
				for(int rX = 0; rX < (areaRadius*2)+1 && (same||same2||same3) ;rX++)
				{
					for(int rZ = 0; rZ < (areaRadius*2)+1 && (same||same2||same3);rZ++)
					{
						if(Math.abs(rX - areaRadius) + Math.abs(rZ - areaRadius) <= areaRadius && same)
						{
							if(initialVal == false)
							{
								initialValue = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]);
								initialVal = true;
							}
							else
							{
								same = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]) == initialValue;
							}
						}
						if(Math.abs(rX - areaRadius) + Math.abs(rZ - areaRadius) <= peakRadius && same2)
						{
							if(initialVal2 == false)
							{
								initialValue2 = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]);
								initialVal2 = true;
							}
							else
							{
								same2 = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]) == initialValue2;
							}
						}
						if(Math.abs(rX - areaRadius) + Math.abs(rZ - areaRadius) <= rangeRadius && same3)
						{
							if(initialVal3 == false)
							{
								initialValue3 = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]);
								initialVal3 = true;
							}
							else
							{
								same3 = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]) == initialValue3;
							}
						}
					}
				}
				/*initialVal = false;
				initialValue = -1;
				for(int rX = (areaRadius - peakRadius) ; rX < ((areaRadius)+1 + peakRadius)&& same2 && !same;rX++)
				{
					for(int rZ = (areaRadius - peakRadius); rZ < ((areaRadius)+1 + peakRadius) && same2 && !same;rZ++)
					{
						if(Math.abs(rX - areaRadius) + Math.abs(rZ - areaRadius) <= areaRadius)
						{
							if(initialVal == false)
							{
								initialValue = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]);
								initialVal = true;
								continue;
							}
							same2 = this.calcWidth(parentCache[x+rX + (z + rZ)*parentXSize]) == initialValue;
						}
					}
				}*/

				if (/*c == xMinus && c == zMinus && c == xPlus && c == zPlus*/ same || !canDoFoothills)
				{
					outCache[x + z * xSize] = 0;
				}
				else if(same3 && canDoFoothills && !same)
				{
					outCache[x + z * xSize] = TFCBiome.FOOTHILLS.biomeID;
				}
				else if(same2 && canDoEdge  && !same)
				{
					outCache[x + z * xSize] = TFCBiome.MOUNTAIN_RANGE_EDGE.biomeID;
				}
				else if(canDoPeak  && !same)
				{
					outCache[x + z * xSize] = TFCBiome.MOUNTAIN_RANGE.biomeID;
				}
				else 
				{
					outCache[x + z * xSize] = 0;
				}
			}
		}

		return outCache;
	}

	private int calcWidth(int i)
	{
		return  i >= 2 ? 2 + (i & 1) : i; // Spits back 2 for even numbers >= 2 and 3 for odd numbers.
	}
}
