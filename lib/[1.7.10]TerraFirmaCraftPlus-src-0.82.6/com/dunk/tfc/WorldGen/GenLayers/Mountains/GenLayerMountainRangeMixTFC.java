package com.dunk.tfc.WorldGen.GenLayers.Mountains;

import com.dunk.tfc.Core.TFC_Core;
import com.dunk.tfc.WorldGen.TFCBiome;
import com.dunk.tfc.WorldGen.GenLayers.GenLayerTFC;

import net.minecraft.world.gen.layer.GenLayer;

public class GenLayerMountainRangeMixTFC extends GenLayerTFC
{
	private GenLayer biomePatternGeneratorChain;
	private GenLayer mountainPatternGeneratorChain;
	private int[] layerBiomes;
	private int[] layerMountains;
	private int[] layerOut;
	private int xn;
	private int xp;
	private int zn;
	private int zp;

	public GenLayerMountainRangeMixTFC(long par1,  GenLayer par3GenLayer, GenLayer par4GenLayer)
	{
		super(par1);
		this.biomePatternGeneratorChain = par3GenLayer;
		this.mountainPatternGeneratorChain = par4GenLayer;
	}

	/**
	 * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
	 * amounts, or biomeList[] indices based on the particular GenLayer subclass.
	 */
	@Override
	public int[] getInts(int x, int z, int xSize, int zSize)
	{
		layerBiomes = this.biomePatternGeneratorChain.getInts(x, z, xSize, zSize);
		layerMountains = this.mountainPatternGeneratorChain.getInts(x, z, xSize, zSize);
		layerOut = new int[xSize * zSize];

		for (int zElement = 0; zElement < zSize; ++zElement)
		{
			for (int xElement = 0; xElement < xSize; ++xElement)
			{
				int index = xElement + zElement * xSize;
				int b = layerBiomes[index];
				int r = layerMountains[index];

				xn = index-1;
				xp = index+1;
				zn = index-zSize;
				zp = index+zSize;

				if (TFC_Core.isOceanicBiome(b) /*|| TFC_Core.isMountainBiome(b)*/)
					layerOut[index] = b;
				else if (r > 0)
				{
					layerOut[index] = r;

					//Here we make sure that rivers dont run along ocean/beach splits. We turn the river into oceans.
					/*if (TFC_Core.isBeachBiome(b))
					{
						layerOut[index] = TFCBiome.OCEAN.biomeID;
						if(inBounds(xn, layerOut) && (layerOut[xn] == TFCBiome.MOUNTAIN_RANGE.biomeID || layerOut[xn] == TFCBiome.MOUNTAIN_RANGE_EDGE.biomeID || layerOut[xn] == TFCBiome.FOOTHILLS.biomeID ))
						{
							layerOut[xn] = TFCBiome.OCEAN.biomeID;
						}
						if(inBounds(zn, layerOut) && (layerOut[xn] == TFCBiome.MOUNTAIN_RANGE.biomeID || layerOut[xn] == TFCBiome.MOUNTAIN_RANGE_EDGE.biomeID || layerOut[xn] == TFCBiome.FOOTHILLS.biomeID ))
						{
							layerOut[zn] = TFCBiome.OCEAN.biomeID;
						}
						if(inBounds(zp, layerOut) && TFC_Core.isOceanicBiome(layerBiomes[zp]) && layerMountains[zp] == 0)
						{
							layerOut[index] = b;
						}
						if(inBounds(zn, layerOut) && TFC_Core.isOceanicBiome(layerBiomes[zn]) && layerMountains[zn] == 0)
						{
							layerOut[index] = b;
						}
						if(inBounds(xn, layerOut) && TFC_Core.isOceanicBiome(layerBiomes[xn]) && layerMountains[xn] == 0)
						{
							layerOut[index] = b;
						}
						if(inBounds(xp, layerOut) && TFC_Core.isOceanicBiome(layerBiomes[xp]) && layerMountains[xp] == 0)
						{
							layerOut[index] = b;
						}
					}*/
				}
				else
					layerOut[index] = b;

				//Similar to above, if we're near a lake, we turn the river into lake.
				removeMountainRange(index, TFCBiome.LAKE.biomeID);
				removeMountainRange(index, TFCBiome.OCEAN.biomeID);
				removeMountainRange(index, TFCBiome.DEEP_OCEAN.biomeID);
				removeMountainRange(index, TFCBiome.RIVER.biomeID);
				removeMountainRange(index, TFCBiome.BEACH.biomeID);
				removeMountainRange(index, TFCBiome.GRAVEL_BEACH.biomeID);
			//	removeMountainRange(index, TFCBiome.MOUNTAINS_EDGE.biomeID);

				validateInt(layerOut, index);
			}
		}
		return layerOut.clone();
	}

	public void removeMountainRange(int index, int biomeToReplaceWith)
	{		
		if((layerOut[index] == TFCBiome.MOUNTAIN_RANGE.biomeID || layerOut[index] == TFCBiome.MOUNTAIN_RANGE_EDGE.biomeID || layerOut[index] == TFCBiome.FOOTHILLS.biomeID ))
		{
			if(xn >= 0 && layerBiomes[xn] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
			if(zn >= 0 && layerBiomes[zn] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
			if(xp < layerBiomes.length && layerBiomes[xp] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
			if(zp < layerBiomes.length && layerBiomes[zp] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
		}
	}

	public boolean inBounds(int index, int[] array)
	{
		return index < array.length && index >= 0;
	}

	/**
	 * Initialize layer's local worldGenSeed based on its own baseSeed and the world's global seed (passed in as an
	 * argument).
	 */
	@Override
	public void initWorldGenSeed(long par1)
	{
		this.biomePatternGeneratorChain.initWorldGenSeed(par1);
		this.mountainPatternGeneratorChain.initWorldGenSeed(par1);
		super.initWorldGenSeed(par1);
	}
}
